-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/fpclass/large-arithmetic-collider#readme</a>
@package large-arithmetic-collider
@version 2022.0.0.0

module Game

-- | Represents different actions (including their parameters) that a cell
--   can have on a row or column total.
data Action
Add :: Int -> Action
Sub :: Int -> Action

-- | Represents a cell including whether it is enabled and its action.
data Cell
MkCell :: Bool -> Action -> Cell

-- | A row has a target number and consists of zero or more cells.
data Row
MkRow :: Int -> [Cell] -> Row

-- | A grid is comprised of the target numbers for all columns and the
--   rows.
data Grid
MkGrid :: [Int] -> [Row] -> Grid

-- | Enumerates directions in which lists can be rotated.
data Direction
L :: Direction
R :: Direction

-- | <a>eval</a> <tt>action total</tt> applies <tt>action</tt> to the
--   running <tt>total</tt>. For example:
--   
--   <pre>
--   &gt;&gt;&gt; eval (Add 5) 3
--   8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; eval (Sub 1) 3
--   2
--   </pre>
eval :: Action -> Int -> Int

-- | <a>apply</a> <tt>cell total</tt> applies the action of <tt>cell</tt>
--   to the running <tt>total</tt> if <tt>cell</tt> is enabled. For
--   example:
--   
--   <pre>
--   &gt;&gt;&gt; apply (MkCell True (Add 5)) 3
--   8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; apply (MkCell False (Add 5)) 3
--   3
--   </pre>
apply :: Cell -> Int -> Int

-- | <a>result</a> <tt>cells</tt> calculates the total produced by the
--   actions of all enabled cells in <tt>cells</tt> starting from 0. For
--   example:
--   
--   <pre>
--   &gt;&gt;&gt; result []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; result [MkCell True (Add 5), MkCell False (Add 5), MkCell True (Sub 1)]
--   4
--   </pre>
result :: [Cell] -> Int

-- | <a>states</a> <tt>cell</tt> is a function which returns a list with
--   _exactly_ two elements that represent the two different states
--   <tt>cell</tt> can be in. For example:
--   
--   <pre>
--   &gt;&gt;&gt; states (MkCell False (Add 5))
--   [MkCell True (Add 5), MkCell False (Add 5)]
--   </pre>
states :: Cell -> [Cell]

-- | <a>candidates</a> <tt>cells</tt> is a function which, given a list of
--   cells in a row, produces all possible combinations of states for those
--   cells. For example:
--   
--   <pre>
--   &gt;&gt;&gt; candidates [MkCell False (Add 5), MkCell False (Sub 1)]
--   [ [MkCell False (Add 5), MkCell False (Sub 1)]
--   , [MkCell False (Add 5), MkCell True (Sub 1)]
--   , [MkCell True (Add 5), MkCell False (Sub 1)]
--   , [MkCell True (Add 5), MkCell True (Sub 1)]
--   ]
--   </pre>
candidates :: [Cell] -> [[Cell]]

-- | <a>solveRow</a> <tt>row</tt> finds solutions for <tt>row</tt>. For
--   example:
--   
--   <pre>
--   &gt;&gt;&gt; solveRow (MkRow 5 [MkCell False (Add 5), MkCell False (Sub 1)])
--   [ MkRow 5 [MkCell True (Add 5), MkCell False (Sub 1)]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; solveRow (MkRow 5 [MkCell False (Add 5), MkCell False (Add 5)])
--   [ MkRow 5 [MkCell True (Add 5), MkCell False (Add 5)]
--   , MkRow 5 [MkCell False (Add 5), MkCell True (Add 5)]
--   ]
--   </pre>
solveRow :: Row -> [Row]

-- | <a>solve</a> <tt>grid</tt> finds all solutions for <tt>grid</tt>. For
--   example:
--   
--   <pre>
--   &gt;&gt;&gt; let row0 = MkRow 3 [MkCell False (Add 3), MkCell False (Add 5)]
--   
--   &gt;&gt;&gt; let row1 = MkRow 4 [MkCell False (Add 2), MkCell False (Add 2)]
--   
--   &gt;&gt;&gt; solve (MkGrid [5, 2] [row0, row1])
--   [ MkGrid [5,2] [ MkRow 3 [MkCell True (Add 3), MkCell False (Add 5)]
--                  , MkRow 4 [MkCell True (Add 2), MkCell True (Add 2)]
--                  ]
--   ]
--   </pre>
solve :: Grid -> [Grid]

-- | <a>rotate</a> <tt>direction list</tt> rotates the items in
--   <tt>list</tt> to the left or right depending on the value of
--   <tt>direction</tt>. For example:
--   
--   <pre>
--   &gt;&gt;&gt; rotate L [1,2,3]
--   [2,3,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; rotate R [1,2,3]
--   [3,1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; rotate L []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; rotate R [1]
--   [1]
--   </pre>
rotate :: Direction -> [a] -> [a]

-- | <a>rotations</a> <tt>grid</tt> returns a list of grids containing all
--   possible ways to rotate <tt>grid</tt>. This means the resulting list
--   should normally have rows + columns many elements. For example:
--   
--   <pre>
--   &gt;&gt;&gt; let row0 = MkRow 3 [MkCell False (Add 3), MkCell False (Add 5)]
--   
--   &gt;&gt;&gt; let row1 = MkRow 4 [MkCell False (Add 2), MkCell False (Add 2)]
--   
--   &gt;&gt;&gt; rotations (MkGrid [5, 2] [row0, row1])
--   [ MkGrid [5,2] [ MkRow 3 [MkCell False (Add 5), MkCell False (Add 3)]
--                  , MkRow 4 [MkCell False (Add 2), MkCell False (Add 2)]
--                  ]
--   , MkGrid [5,2] [ MkRow 3 [MkCell False (Add 3), MkCell False (Add 5)]
--                  , MkRow 4 [MkCell False (Add 2), MkCell False (Add 2)]
--                  ]
--   , MkGrid [5,2] [ MkRow 3 [MkCell False (Add 2), MkCell False (Add 5)]
--                  , MkRow 4 [MkCell False (Add 3), MkCell False (Add 2)]
--                  ]
--   , MkGrid [5,2] [ MkRow 3 [MkCell False (Add 3), MkCell False (Add 2)]
--                  , MkRow 4 [MkCell False (Add 2), MkCell False (Add 5)]
--                  ]
--   ]
--   </pre>
rotations :: Grid -> [Grid]

-- | <a>steps</a> <tt>grid</tt> finds the sequence of rotations that lead
--   to a solution for <tt>grid</tt> in the fewest number of rotations. The
--   resulting list includes the solution as the last element. You may
--   assume that this function will never be called on a <tt>grid</tt> for
--   which there are solutions returned by <a>solve</a>. The states of
--   intermediate grids in the resulting list are irrelevant - only the
--   ones of the final grid need to be set correctly.
--   
--   <pre>
--   &gt;&gt;&gt; let row0 = MkRow 3 [MkCell False (Add 2), MkCell False (Add 3)]
--   
--   &gt;&gt;&gt; let row1 = MkRow 4 [MkCell False (Add 5), MkCell False (Add 2)]
--   
--   &gt;&gt;&gt; steps (MkGrid [5, 2] [row0, row1])
--   [ MkGrid [5, 2] [ MkRow 3 [ MkCell False (Add 5), MkCell False (Add 3)]
--                   , MkRow 4 [ MkCell False (Add 2), MkCell False (Add 2)]
--                   ]
--   , MkGrid [5, 2] [ MkRow 3 [ MkCell True (Add 3), MkCell False (Add 5)]
--                   , MkRow 4 [ MkCell True (Add 2), MkCell True (Add 2)]
--                   ]
--   ]
--   </pre>
steps :: Grid -> [Grid]
instance GHC.Show.Show Game.Action
instance GHC.Classes.Ord Game.Action
instance GHC.Classes.Eq Game.Action
instance GHC.Show.Show Game.Cell
instance GHC.Classes.Eq Game.Cell
instance GHC.Show.Show Game.Row
instance GHC.Classes.Eq Game.Row
instance GHC.Show.Show Game.Grid
instance GHC.Classes.Eq Game.Grid
instance GHC.Show.Show Game.Direction
instance GHC.Classes.Eq Game.Direction


-- | This module contains types to represent levels and campaigns along
--   with functions to load/save levels and campaigns.
module Level

-- | Represents a level consisting of a par number of rotations and a grid.
data Level
MkLevel :: Int -> Grid -> Level

-- | The par number of rotations required to solve this level.
[levelPar] :: Level -> Int

-- | The grid that makes up the level.
[levelGrid] :: Level -> Grid

-- | <a>loadLevel</a> <tt>filepath</tt> tries to load a level from
--   <tt>filepath</tt>.
loadLevel :: FilePath -> IO (Either String Level)

-- | <a>saveLevel</a> <tt>filepath level</tt> saves <tt>level</tt> to
--   <tt>filepath</tt>.
saveLevel :: FilePath -> Level -> IO ()

-- | Represents a campaign (a collection of levels).
data Campaign
MkCampaign :: String -> String -> FilePath -> Campaign

-- | The title of the campaign.
[campaignTitle] :: Campaign -> String

-- | The description of the campaign.
[campaignDesc] :: Campaign -> String

-- | The path to the levels folder for this campaign.
[campaignPath] :: Campaign -> FilePath

-- | <a>listCampaigns</a> is a computation which loads the list of
--   campaigns.
listCampaigns :: IO (Maybe [Campaign])

-- | <a>loadLevels</a> <tt>directory</tt> attempts to load all levels from
--   <tt>directory</tt>.
loadLevels :: FilePath -> IO (Either String [Level])
instance GHC.Show.Show Level.Level
instance GHC.Classes.Eq Level.Level
instance GHC.Show.Show Level.Campaign
instance GHC.Classes.Eq Level.Campaign
instance Data.Aeson.Types.FromJSON.FromJSON Level.Campaign
instance Data.Aeson.Types.ToJSON.ToJSON Level.Level
instance Data.Aeson.Types.FromJSON.FromJSON Level.Level
instance Data.Aeson.Types.ToJSON.ToJSON Game.Action
instance Data.Aeson.Types.FromJSON.FromJSON Game.Action
instance Data.Aeson.Types.ToJSON.ToJSON Game.Cell
instance Data.Aeson.Types.FromJSON.FromJSON Game.Cell
instance Data.Aeson.Types.ToJSON.ToJSON Game.Row
instance Data.Aeson.Types.FromJSON.FromJSON Game.Row
instance Data.Aeson.Types.ToJSON.ToJSON Game.Grid
instance Data.Aeson.Types.FromJSON.FromJSON Game.Grid
